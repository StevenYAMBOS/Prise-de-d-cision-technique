# Prise de décision technique

<p align="center">
  <a href="https://youtu.be/3FmN46XQius" target="blank"><img src="https://ik.imagekit.io/mdzi40eohii/tsc/Full_Stack_Image_daa0e85929_mkCd6n2su.png?tr=w-3840,q-75" width="800" alt="Pile technologique" /></a>
</p>

## Sommaire

- [I - Smash Here](#i---smash-here)
  - [A - Introduction](#a---introduction)
  - [B - Vision](#b---vision)
    - [Scalabilité](#1---scalabilité)
    - [Sécurité](#2---sécurité)
    - [Évolutivité](#3---évolutivité)
    - [Coûts](#4---coûts)
  - [C - Fonctionnalités](#c---fonctionnalités)
  - [D - Compétences techniques](#d---compétences-techniques)
    - [1 - Langage Front-End](#1---langage-front-end)
    - [2 - Langage Back-End](#2---langage-back-end)
    - [3 - Framework Front-End](#3---framework-front-end)
    - [4 - Framework Back-End](#4---framework-back-end)
    - [5 - Base de données](#5---base-de-données)

- [II - Matrices décisionnelles](#ii---matrices-décisionnelles)
  - [A - Langages Front-End](#a---langages-front-end)
  - [B - Langages Back-End](#b---langages-back-end)
  - [C - Frameworks Front-End](#c---frameworks-front-end)
  - [D - Frameworks Back-End](#d---frameworks-back-end)
  - [E - Bases de données](#e---bases-de-données)

## I - Smash Here

### A - Introduction

**Smash Here** est une plateforme e-sport dédiée aux jeux de combat.

Elle vise à offrir aux joueurs et coachs des outils d'apprentissage interactifs et personnalisés sous forme de roadmaps adaptées aux différents niveaux de compétence de chacun.

### B - Vision

Smash Here sera dans un premier temps une plateforme Web, puis sur le long terme elle sera développée sur mobile (Android et iOS) nativement (Kotlin et Swift) dans l'idée d'y ajouter des fonctionnalités Natives.

Le développement de la plateforme va se concentrer sur les points suivants :

#### 1 - Scalabilité

Au fur et à mesure des mises à jour la plateforme emmagasinera énormément de données/informations, elle se doit d'être scalable.

#### 2 - Sécurité

Les coachs E-Sportif proposerons des Roadmaps personnalisées, l'application se doit être sécurisée pour éviter les vols et le plagiat.

#### 3 - Évolutivité

Une version mobile de l'application sera développée.
L'intégration d'une dizaine de jeux de combats est prévue courant 2026.

#### 4 - Coûts

L'équipe étant réduite la plateforme ne doit pas coûter cher à développer et maintenir.

### C - Fonctionnalités

- Création/affichage/partage de Roadmaps
- Chats
- Paiement/Abonnements

### D - Compétences techniques

L'équipe est composé d'un développeur, de ce fait il aura la charge de développer l'entièreté du projet (Front-End, Back-End et mobile).

Le développeur connaît les technologies suivantes :

#### 1 - Langage Front-End

- **Javascript** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/JavaScript-logo.png/600px-JavaScript-logo.png" width="30px" alt="Javascript logo" />
- **Typescript** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/1200px-Typescript_logo_2020.svg.png" width="30px" alt="Typescript logo" />
- **CSS** <img src="https://cdn.pixabay.com/photo/2017/08/05/11/16/logo-2582747_1280.png" width="30px" alt="CSS logo" />

#### 2 - Langage Back-End

- **Java** <img src="https://logos-marques.com/wp-content/uploads/2021/03/Java-Logo.png" width="30px" alt="Java logo"/>
- **Go** <img src="https://cdn.worldvectorlogo.com/logos/golang-gopher.svg" width="30px" alt="Golang logo" />
- **NodeJs** <img src="https://static-00.iconduck.com/assets.00/node-js-icon-454x512-nztofx17.png" width="30px" alt="NodeJS logo" />
- **Python** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/701px-Python-logo-notext.svg.png" width="30px" alt="Python logo" />

#### 3 - Framework Front-End

- **ReactJS** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/React-icon.svg/2300px-React-icon.svg.png" width="30px" alt="ReactJS logo" />
- **AngularJS** <img src="https://seeklogo.com/images/A/angular-icon-logo-5FC0C40EAC-seeklogo.com.png" width="30px" alt="AngularJS logo" />

#### 4 - Framework Back-End

- **Spring Boot** <img src="https://img.icons8.com/?size=512&id=90519&format=png" width="30px" alt="Spring Boot logo" />
- **Fiber** <img src="https://repository-images.githubusercontent.com/234231371/00fd8700-5430-11ea-820b-15fd85b2472c" width="30px" alt="Fiber logo" />
- **ExpressJS** <img src="https://upload.wikimedia.org/wikipedia/commons/6/64/Expressjs.png" width="30px" alt="ExpressJS logo" />
- **Flask** <img src="https://cdn.worldvectorlogo.com/logos/flask.svg" width="30px" alt="Flask logo" />

#### 5 - Base de données

- **MongoDB** <img src="https://www.svgrepo.com/show/331488/mongodb.svg" width="30px" alt="MongoDB logo" />
- **PostgreSQL** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Postgresql_elephant.svg/993px-Postgresql_elephant.svg.png" width="30px" alt="PostgreSQL logo" />

Affinité du développeur avec chaque technologie :

| Technologie    | Affinité | Explication                                                                                     |
|----------------|----------------|-------------------------------------------------------------------------------------------------|
| **JavaScript** | 4              | Utilisé quotidiennement, le développeur est familier avec son écosystème.                        |
| **TypeScript** | 3              | Utilisé régulièrement, le développeur est familier avec son écosystème.                          |
| **Java**       | 4              | Langage d’origine, le développeur est familier avec son écosystème.                             |
| **Go**         | 2              | Expérience de quelques side-projects, mais sans grande profondeur dans le langage.              |
| **Python**     | 3              | A travaillé sur quelques projets, une certaine familiarité.                                     |
| **ReactJS**    | 3              | Utilisé quotidiennement, le développeur est familier avec son écosystème.                        |
| **Angular**    | 3              | Quelques side-projects, une certaine familiarité mais pas en profondeur.                        |
| **Spring Boot**| 4              | Langage d’origine, le développeur est familier avec son écosystème.                             |
| **Fiber**      | 2              | Expérience de quelques side-projects, mais pas de grande profondeur.                            |
| **ExpressJS**  | 4              | Utilisé quotidiennement avec JavaScript, le développeur est familier avec son écosystème.       |
| **Flask**      | 2              | A travaillé sur quelques projets mais sans grande profondeur.                                   |
| **MongoDB**    | 4              | Utilisé quotidiennement, le développeur est familier avec son écosystème.                        |
| **PostgreSQL** | 2              | Quelques projets, mais sans grande profondeur.                                                 |

## II - Matrices décisionnelles

### A - Langages Front-End

Pour la matrice décisionnelle concernant le choix du langage front-end pour votre projet, voici une évaluation des principaux langages couramment utilisés pour le développement web. Les langages choisis sont **JavaScript**, **TypeScript**, et **Dart**.

J'ai décidé d'intégrer Dart car il permet un développement Full-Stack.

Les notes sont basées sur des critères de performance, facilité d'apprentissage, coût de développement, durabilité à long terme, temps de développement, consommation d'énergie, popularité et lisibilité de la syntaxe.

Ces informations s’appuient sur des sources diverses telles que <a href="https://survey.stackoverflow.co/2024/" target="_blank">**Stack Overflow Developer Survey**</a>, <a href="https://stateofjs.com/en-US" target="_blank">**State of JS 2022**</a>, <a href="https://mdn.dev/archives/insights/" target="_blank">**MDN Web Docs**</a>.

Les notes sont basées sur des critères de performance, facilité d'apprentissage, coût de développement, durabilité à long terme, temps de développement, consommation d'énergie, popularité et lisibilité de la syntaxe. Ces informations s’appuient sur des sources diverses telles que **Stack Overflow Developer Survey**, **State of JS**, et des analyses de développeurs web reconnus.

| Langages     | Performance | Facilité d'apprentissage | Coût de développement | Durabilité à long terme | Temps de développement | Consommation d'énergie | Popularité du langage | Syntaxe et lisibilité | Maîtrise du développeur |
|--------------|-------------|--------------------------|------------------------|-------------------------|------------------------|------------------------|------------------------|------------------------|--------------------------|
| JavaScript   | 4           | 4                        | 4                      | 5                       | 5                      | 3                      | 5                      | 4                      | 4                        |
| TypeScript   | 4           | 3                        | 4                      | 5                       | 4                      | 3                      | 4                      | 5                      | 3                        |
| Dart         | 3           | 3                        | 3                      | 4                       | 3                      | 4                      | 3                      | 4                      | 0                      |

**JavaScript** :

- **Performance** : Élevée, car il s’agit d’un langage interprété côté client, permettant des interactions dynamiques et rapides.
- **Facilité d'apprentissage** : Très accessible, avec une grande documentation et de nombreux tutoriels pour débutants.
- **Coût de développement** : Faible, car il bénéficie d'une large communauté open-source et de nombreuses bibliothèques gratuites.
- **Durabilité à long terme** : Très solide, JavaScript étant le langage principal du web depuis des décennies.
- **Temps de développement** : Optimal, JavaScript est bien supporté par la plupart des frameworks modernes (React, Angular, Vue).
- **Consommation d'énergie** : Moyenne, dépend des optimisations et du navigateur.
- **Popularité** : Très populaire, étant le langage web dominant (Source : Stack Overflow Developer Survey).
- **Syntaxe et lisibilité** : Bonne lisibilité, bien que complexe pour les fonctionnalités avancées.

**TypeScript** :

- **Performance** : Comparable à JavaScript, car il compile en JavaScript.
- **Facilité d'apprentissage** : Un peu plus complexe que JavaScript en raison de la typage statique.
- **Coût de développement** : Faible, avec une communauté croissante et des outils bien intégrés.
- **Durabilité à long terme** : Très élevée, étant de plus en plus adopté dans l’industrie pour sa robustesse.
- **Temps de développement** : Moins rapide que JavaScript, mais améliore la détection des erreurs dès la compilation.
- **Consommation d'énergie** : Moyenne, car similaire à JavaScript.
- **Popularité** : En croissance, souvent préféré dans des projets de grande envergure pour sa maintenabilité.
- **Syntaxe et lisibilité** : Très lisible, avec un typage fort qui améliore la compréhension.

**Dart** :

- **Performance** : Bonne, surtout lorsqu'il est utilisé avec Flutter pour des applications web et mobiles.
- **Facilité d'apprentissage** : Moyenne, moins accessible que JavaScript et TypeScript.
- **Coût de développement** : Légèrement plus élevé, car moins de développeurs maîtrisent Dart.
- **Durabilité à long terme** : Prometteuse, mais encore incertaine en dehors de l'écosystème Google.
- **Temps de développement** : Plus long, car moins de bibliothèques disponibles.
- **Consommation d'énergie** : Moyenne, bien optimisée avec Flutter.
- **Popularité** : Moins populaire que JavaScript et TypeScript, mais en croissance grâce à Flutter.
- **Syntaxe et lisibilité** : Bonne, similaire à JavaScript avec des améliorations de lisibilité.

Voici une matrice de décision pour les langages Back-End que vous envisagez (Python, Node.js, Java, Go, Rust) pour le développement de votre plateforme. Cette matrice prend en compte divers critères importants pour un projet comme le vôtre, avec une notation de 1 à 5 pour chaque critère.

### B - Langages Back-End

L'avantage du Back-End est qu'il pourra servir pour toutes les solutions Front-End.

Nous avons intégré **Rust** dans cette liste car c'est un langage que le dévelopeur reste favorable à son utilisation potentielle pour le projet.

| Langages | Performance | Facilité d'apprentissage | Coût de développement | Durabilité à long terme | Temps de développement | Consommation d'énergie | Popularité du langage | Syntaxe et lisibilité | Maîtrise du développeur |
|----------|-------------|--------------------------|------------------------|-------------------------|------------------------|------------------------|------------------------|------------------------|--------------------------|
| Java     | 5           | 3                        | 4                      | 5                       | 4                      | 4                      | 5                      | 4                      | 4                        |
| Go       | 5           | 3                        | 4                      | 4                       | 3                      | 5                      | 4                      | 4                      | 2                        |
| Python   | 4           | 5                        | 3                      | 5                       | 5                      | 3                      | 5                      | 5                      | 3                        |
| Node.js  | 4           | 4                        | 4                      | 4                       | 5                      | 4                      | 5                      | 4                      | 4                        |
| Rust     | 5           | 2                        | 3                      | 5                       | 3                      | 5                      | 3                      | 3                      | 0                      |

**Performance**

- **Java, Go, et Rust** sont réputés pour leurs performances élevées, notamment grâce à leur gestion efficace de la mémoire et leurs capacités de traitement. Rust excelle particulièrement dans ce domaine avec une optimisation de bas niveau sans compromis sur la sécurité.
- **Python et Node.js** offrent des performances modérées mais peuvent être optimisés pour des applications web et API, bien qu'ils ne soient pas aussi rapides que les autres langages pour des applications très intensives en calcul.

**Facilité d'apprentissage**

- **Python et Node.js** sont très accessibles, surtout pour des développeurs débutants ou intermédiaires, ce qui réduit le temps nécessaire pour atteindre une productivité élevée.
- **Go** a une courbe d'apprentissage modérée et est relativement simple pour les développeurs venant de langages orientés objets.
- **Java** est plus complexe en raison de son écosystème large et de sa structure stricte.
- **Rust** est le plus difficile à apprendre en raison de sa syntaxe complexe et de ses concepts avancés de gestion de mémoire.

**Coût de développement**

- **Python et Node.js** sont associés à des coûts de développement relativement faibles, principalement en raison de leurs vastes écosystèmes de bibliothèques et leur communauté active.
- **Go** et **Java** nécessitent davantage de temps et de connaissances avancées, augmentant ainsi les coûts, bien que leur écosystème soit bien fourni.
- **Rust** a des coûts potentiellement élevés dus à sa courbe d’apprentissage et à sa relative nouveauté, limitant la disponibilité des développeurs spécialisés.

**Durabilité à long terme**

- **Java** est souvent choisi pour sa stabilité et sa robustesse à long terme, notamment dans les grandes entreprises.
- **Python, Go, et Rust** sont également bien positionnés en matière de durabilité, Rust ayant particulièrement gagné en popularité auprès des entreprises technologiques de pointe.
- **Node.js** est relativement durable grâce à l’écosystème JavaScript, mais des alternatives plus performantes peuvent être envisagées selon les besoins du projet.

**Temps de développement**

- **Python et Node.js** sont conçus pour une productivité rapide, réduisant le temps de développement, particulièrement pour des projets web et API.
- **Go** est également rapide pour le développement, notamment grâce à sa simplicité et à son modèle de concurrence intégré.
- **Java** et **Rust** peuvent nécessiter plus de temps en raison de leur complexité et de leur verbosité (surtout pour Java), mais produisent des applications robustes.

**Consommation d'énergie**

- **Rust** et **Go** consomment moins d’énergie, car ils sont optimisés pour l’efficacité et la gestion de la mémoire.
- **Java** et **Python** ont une consommation énergétique moyenne.
- **Node.js** a une consommation d’énergie plus élevée dans certains cas, notamment lorsque les processus sont intensifs ou non optimisés pour des charges importantes.

**Popularité du langage**

- **Python et JavaScript (Node.js)** sont parmi les langages les plus populaires, bénéficiant d’une vaste communauté et d'un large choix de ressources.
- **Java** reste très populaire dans le secteur des entreprises.
- **Go** et **Rust** gagnent rapidement en popularité, mais leur adoption est moins étendue.

**Syntaxe et lisibilité**

- **Python** excelle dans la lisibilité, permettant de maintenir un code propre et accessible.
- **Node.js** est également bien noté, bien que certaines complexités dans la gestion des promesses et des asynchrones puissent nuire à la lisibilité.
- **Go** est conçu pour être lisible et minimaliste, bien qu’il manque certaines fonctionnalités avancées.
- **Java** et **Rust** sont moins accessibles en raison de leur verbosité et de leur structure plus rigide (Java) ou complexe (Rust).

**Sources**

- Stack Overflow Developer Survey 2023 : [https://insights.stackoverflow.com/survey/2023](https://insights.stackoverflow.com/survey/2023)
- State of Developer Ecosystem by JetBrains : [https://www.jetbrains.com/lp/devecosystem-2023/](https://www.jetbrains.com/lp/devecosystem-2023/)
- GitHub Octoverse 2023 : [https://octoverse.github.com/](https://octoverse.github.com/)

### C - Frameworks Front-End

Le développeur est entièrement ouvert concernant l'utilisation du Framework Front-End. Il a cependant quelques réserves sur l'utilisation de Flutter (car il ne maîtrise pas le Dart bien qu'il se rapproche du Javascript).

| Framework | Performance | Écosystème | Développement | Architecture | Déploiement | Sécurité | Coûts | Mobile/Responsive |
|-----------|-------------|------------|---------------|--------------|-------------|----------|-------|--------------------|
| React     | 4           | 5          | 5             | 4            | 5           | 4        | 5     | 5                  |
| Vue.js    | 4           | 4          | 5             | 4            | 5           | 4        | 5     | 4                  |
| Svelte    | 5           | 3          | 4             | 3            | 4           | 3        | 5     | 4                  |
| Angular   | 4           | 5          | 3             | 5            | 5           | 5        | 4     | 5                  |
| Flutter (Web) | 3       | 3          | 4             | 4            | 4           | 4        | 5     | 5                  |

**Performance**

- **Svelte** excelle en performance, car il compile directement le code au moment du build, sans dépendre d'un runtime lourd, ce qui allège le code final.
- **React, Vue.js, et Angular** offrent des performances solides, bien qu’Angular puisse être plus lourd en raison de ses fonctionnalités intégrées.
- **Flutter (Web)** est performant mais légèrement en deçà pour le Web, car il n'est pas originellement conçu pour les applications Web.

**Écosystème**

- **React** dispose d'un écosystème large et mature avec une multitude de bibliothèques, plugins et extensions disponibles. Sa popularité permet un choix varié de ressources.
- **Vue.js** et **Angular** possèdent également des écosystèmes solides, mais React reste en tête en termes de disponibilité de packages et de communauté.
- **Svelte** et **Flutter (Web)** ont des écosystèmes moins étendus, bien que Flutter soit soutenu par Google et commence à s’enrichir.

**Développement**

- **React et Vue.js** sont appréciés pour leur facilité de prise en main et la rapidité de développement. Les outils comme Vue CLI et Create React App simplifient les démarrages de projet.
- **Svelte** est très intuitif pour les développeurs, mais certains concepts peuvent nécessiter un apprentissage supplémentaire.
- **Angular** est plus complexe, avec une courbe d’apprentissage plus raide en raison de son architecture complète et de TypeScript.
- **Flutter (Web)** simplifie les déploiements multiplateformes, bien que le développement pour le Web puisse présenter quelques limitations en termes de support des API natives du Web.

**Architecture**

- **Angular** est orienté vers une architecture bien structurée avec des modules, services et directives, offrant une bonne organisation pour les projets à grande échelle.
- **React** est flexible et permet différentes architectures, bien que moins structurée qu'Angular.
- **Vue.js** offre une structure équilibrée qui est bien adaptée aux projets de taille moyenne.
- **Svelte** a une structure simple, bien adaptée aux petits projets mais moins robuste pour les applications complexes.
- **Flutter (Web)** est basé sur le système de widgets, qui est intuitif pour le mobile, mais moins adapté aux pratiques Web classiques.

**Déploiement**

- **React, Vue.js, et Angular** sont tous bien adaptés aux déploiements Web, avec des options d’optimisation et des builds légers.
- **Svelte** se distingue par ses builds extrêmement légers.
- **Flutter (Web)** est encore en développement pour le Web et peut nécessiter des ajustements pour des optimisations Web.

**Sécurité**

- **Angular** est reconnu pour ses bonnes pratiques de sécurité par défaut, telles que la protection contre les injections XSS.
- **React** et **Vue.js** sont relativement sûrs, bien que certaines vulnérabilités puissent apparaître si les bonnes pratiques ne sont pas respectées.
- **Svelte** et **Flutter (Web)** n'ont pas les mêmes options de sécurité intégrées que d'autres frameworks, bien que des protections de base puissent être implémentées.

**Coûts**

- Tous ces frameworks sont open-source et gratuits, ce qui minimise les coûts directs.
- **React** et **Vue.js** bénéficient de nombreux outils gratuits et de ressources qui facilitent le développement sans nécessiter des coûts supplémentaires.

**Mobile/Responsive**

- **React** et **Flutter (Web)** offrent une excellente prise en charge des applications responsives et sont idéaux pour le développement multiplateforme, Flutter étant natif pour le mobile.
- **Vue.js** et **Angular** sont également bien adaptés pour les applications responsives, bien que la configuration puisse parfois être plus complexe.
- **Svelte** est également capable de prendre en charge des interfaces adaptatives, mais il est moins utilisé pour les applications multiplateformes.

**Sources**

- **State of JavaScript Survey 2023** : [https://stateofjs.com/en-us/](https://stateofjs.com/en-us/)
- **Stack Overflow Developer Survey 2023** : [https://insights.stackoverflow.com/survey/2023](https://insights.stackoverflow.com/survey/2023)

### D - Frameworks Back-End

| Framework  | Performance | Écosystème | Développement | Architecture | Déploiement | Sécurité | Coûts | Mobile/Responsive |
|------------|-------------|------------|---------------|--------------|-------------|----------|-------|--------------------|
| Django (Python) | 3           | 5          | 4             | 5            | 5           | 5        | 5     | 4                  |
| Express (Node.js) | 4       | 5          | 5             | 4            | 5           | 4        | 5     | 4                  |
| Spring Boot (Java) | 5       | 4          | 3             | 5            | 4           | 5        | 4     | 4                  |
| Gin (Go)         | 5           | 3          | 3             | 4            | 5           | 5        | 4     | 4                  |
| Rocket (Rust)    | 5           | 3          | 2             | 4            | 4           | 5        | 4     | 3                  |

**Performance**

- **Gin (Go)** et **Rocket (Rust)** offrent des performances élevées, car Go et Rust sont conçus pour des applications à faible latence et nécessitant une grande rapidité d'exécution.
- **Spring Boot (Java)** est également performant, particulièrement pour les applications d’entreprise.
- **Express (Node.js)** offre de bonnes performances mais reste moins rapide que Go et Rust pour les charges de travail élevées.
- **Django (Python)** est plus adapté aux applications nécessitant une évolutivité rapide et moins intensives en calcul.

**Écosystème**

- **Django** et **Express** disposent de vastes écosystèmes, riches en bibliothèques, extensions, et une communauté large qui offre de nombreux outils pour le développement rapide.
- **Spring Boot** a également un bon écosystème, mais il est plus orienté vers les applications Java d’entreprise.
- **Gin** et **Rocket** ont des écosystèmes plus limités, bien que la popularité de Go et Rust augmente.

**Développement**

- **Express** est facile à utiliser et bénéficie d'une grande souplesse, tandis que **Django** facilite la rapidité de développement avec ses outils intégrés (ORM, authentification).
- **Spring Boot** est plus complexe, nécessitant une courbe d’apprentissage plus raide.
- **Gin** et **Rocket** demandent des connaissances techniques plus avancées, surtout pour optimiser les performances.

**Architecture**

- **Django** et **Spring Boot** fournissent une architecture bien structurée, adaptée pour des applications complexes, avec un cadre robuste de modélisation et de logique métier.
- **Express** est flexible mais moins structuré.
- **Gin** et **Rocket** nécessitent une structuration manuelle, ce qui offre de la flexibilité mais demande plus d'organisation.

**Déploiement**

- Tous les frameworks se déploient facilement sur la plupart des environnements cloud (AWS, Azure, GCP) et supportent des conteneurs Docker, ce qui est essentiel pour les déploiements modernes.
- **Django**, **Express**, et **Spring Boot** sont bien documentés pour les déploiements, facilitant leur mise en production.

**Sécurité**

- **Spring Boot** et **Django** sont réputés pour leurs pratiques de sécurité intégrées, incluant la gestion des sessions, la protection contre les attaques XSS et CSRF.
- **Rocket** et **Gin** offrent également de bonnes bases de sécurité, mais les mises en place de certaines protections demandent plus de configuration manuelle.
- **Express** est sûr, mais la sécurité dépend des bonnes pratiques du développeur en raison de son minimalisme.

**Coûts**

- Tous ces frameworks sont open-source et gratuits, minimisant ainsi les coûts initiaux de développement.
- **Express** et **Django** sont particulièrement rentables en raison des outils gratuits disponibles pour une productivité accrue.

**Mobile/Responsive**

- Tous les frameworks sont capables de gérer les API et les communications nécessaires pour les applications mobiles, bien que certains (comme Django et Express) soient plus couramment utilisés dans des configurations Web et mobiles.

### E - Bases de données

Concernant la base de données le critère les critères les plus importants pour le projet sont : **scalabilité**, **sécurité**, **coûts**.

| Base de Données      | Performance | Scalabilité | Fiabilité | Modèle de Données | Sécurité | Coûts | Administration | Intégration | Support et Communauté |
|----------------------|-------------|-------------|-----------|-------------------|----------|-------|----------------|-------------|------------------------|
| **PostgreSQL**       | 5           | 4           | 5         | 4                 | 5        | 4     | 4              | 5           | 5                      |
| **MongoDB**          | 4           | 5           | 4         | 5                 | 4        | 4     | 4              | 5           | 5                      |
| **MySQL**            | 4           | 4           | 5         | 3                 | 5        | 5     | 5              | 4           | 5                      |
| **Firebase Firestore** | 3           | 5           | 4         | 4                 | 5        | 3     | 4              | 5           | 4                      |
| **DynamoDB**         | 4           | 5           | 5         | 4                 | 5        | 3     | 3              | 5           | 4                      |

**Performance**

- **PostgreSQL** offre des performances élevées, particulièrement pour les applications transactionnelles et les requêtes complexes.
- **MongoDB** est rapide pour les applications nécessitant des opérations d’écriture fréquentes et volumineuses grâce à son modèle de données non relationnel.
- **MySQL** est stable et performant pour des transactions standards, bien que moins performant que PostgreSQL dans les environnements nécessitant des requêtes avancées.
- **Firebase Firestore** et **DynamoDB** sont conçus pour le cloud et offrent de bonnes performances pour des applications distribuées et mobiles, mais peuvent être plus lents pour des requêtes relationnelles complexes.

**Scalabilité**

- **MongoDB**, **Firestore**, et **DynamoDB** sont conçus pour la scalabilité horizontale, ce qui les rend adaptés aux applications nécessitant un traitement de données volumineuses et une distribution rapide.
- **PostgreSQL** et **MySQL** permettent la scalabilité, mais la mise en place d’une scalabilité horizontale est plus complexe en comparaison des bases de données NoSQL.

**Fiabilité**

- **PostgreSQL** et **MySQL** sont extrêmement fiables pour des transactions ACID, offrant une cohérence forte et des mécanismes de sauvegarde éprouvés.
- **DynamoDB** et **Firestore** offrent une haute disponibilité et une fiabilité basée sur des architectures de réplication en cloud.
- **MongoDB** est également fiable, mais son modèle de cohérence eventual peut introduire des risques de décalage en fonction des besoins spécifiques de l’application.

**Modèle de Données**

- **MongoDB** est idéal pour les données non structurées ou semi-structurées, grâce à son modèle de document JSON.
- **PostgreSQL** et **MySQL** sont plus adaptés aux applications nécessitant un modèle de données relationnel structuré.
- **Firestore** et **DynamoDB** sont optimisés pour le stockage et la récupération rapide de données JSON, facilitant leur intégration avec des applications web et mobiles modernes.

**Sécurité**

- **PostgreSQL**, **MySQL**, **Firestore**, et **DynamoDB** offrent des options robustes en matière de sécurité, y compris le chiffrement des données en transit et au repos, ainsi que des contrôles d’accès granulaires.
- **MongoDB** propose également une bonne sécurité, mais l’activation de certaines fonctionnalités de sécurité nécessite une configuration manuelle et des ajustements.

**Coûts**

- **MySQL** et **PostgreSQL** sont open-source, ce qui en fait des options rentables pour de nombreuses entreprises, bien qu'ils puissent nécessiter des coûts d'infrastructure et d'administration.
- **Firestore** et **DynamoDB** sont basés sur l’usage dans le cloud, avec des coûts variables en fonction de l’utilisation, ce qui peut devenir coûteux pour des applications avec une grande quantité de données.
- **MongoDB** est également open-source, mais les services de cloud gérés par MongoDB (MongoDB Atlas) ont un coût.

**Administration**

- **MySQL** et **PostgreSQL** sont bien documentés et disposent d’outils d’administration avancés, mais nécessitent souvent un DBA pour la gestion avancée.
- **Firestore** et **DynamoDB** sont intégrés dans leurs écosystèmes cloud (respectivement Google Cloud et AWS), réduisant les efforts d’administration.
- **MongoDB** dispose de MongoDB Atlas pour le cloud, simplifiant la gestion mais ajoutant un coût.

**Intégration**

- **Firestore**, **DynamoDB**, et **MongoDB** s’intègrent bien avec les environnements JavaScript et les applications mobiles, offrant des APIs pratiques pour le développement rapide.
- **PostgreSQL** et **MySQL** sont compatibles avec de nombreux langages et plateformes et bénéficient d’un large support pour les intégrations externes.

**Support et Communauté**

- **PostgreSQL**, **MySQL**, et **MongoDB** bénéficient de communautés actives, de documentations étendues et de nombreux forums d’assistance.
- **Firestore** et **DynamoDB** sont supportés par Google Cloud et AWS respectivement, avec une assistance technique dédiée, mais leurs communautés sont légèrement plus restreintes.
