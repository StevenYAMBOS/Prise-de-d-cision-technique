# Prise de décision technique

<p align="center">
  <a href="https://youtu.be/3FmN46XQius" target="blank"><img src="https://ik.imagekit.io/mdzi40eohii/tsc/Full_Stack_Image_daa0e85929_mkCd6n2su.png?tr=w-3840,q-75" width="800" alt="Pile technologique" /></a>
</p>

## Sommaire

- [I - Smash Here](#i---smash-here)
  - [A - Introduction](#a---introduction)
  - [B - Vision](#b---vision)
    - [Scalabilité](#1---scalabilité)
    - [Sécurité](#2---sécurité)
    - [Évolutivité](#3---évolutivité)
    - [Coûts](#4---coûts)
  - [C - Fonctionnalités](#c---fonctionnalités)
  - [D - Compétences techniques](#d---compétences-techniques)
    - [1 - Langage Front-End](#1---langage-front-end)
    - [2 - Langage Back-End](#2---langage-back-end)
    - [3 - Framework Front-End](#3---framework-front-end)
    - [4 - Framework Back-End](#4---framework-back-end)
    - [5 - Base de données](#5---base-de-données)

- [II - Matrices décisionnelles](#ii---matrices-décisionnelles)
  - [A - Langages Front-End](#a---langages-front-end)
  - [B - Langages Back-End](#b---langages-back-end)
  - [C - Frameworks Front-End](#c---frameworks-front-end)
  - [D - Frameworks Back-End](#d---frameworks-back-end)
  - [E - Bases de données](#e---bases-de-données)

- [III - Choix final](#iii---choix-final)
  - [A - Langage Front-End](#a---langage-front-end-1)
  - [B - Framework Front-End](#b---framework-front-end-1)
  - [C - Langage Back-End](#c---langage-back-end-1)
  - [D - Framework Back-End](#d---framework-back-end-1)
  - [E - Base de données](#e---base-de-données-1)


## I - Smash Here

### A - Introduction

**Smash Here** est une plateforme e-sport dédiée aux jeux de combat.

Elle vise à offrir aux joueurs et coachs des outils d'apprentissage interactifs et personnalisés sous forme de roadmaps adaptées aux différents niveaux de compétence de chacun.

### B - Vision

Smash Here sera dans un premier temps une plateforme Web, puis sur le long terme elle sera développée sur mobile (Android et iOS) nativement (**Kotlin** et **Swift**) dans l'idée d'y ajouter des fonctionnalités Natives.

Le développement de la plateforme va se concentrer sur les points suivants :

#### 1 - Scalabilité

Au fur et à mesure des mises à jour la plateforme emmagasinera énormément de données/informations, elle se doit d'être scalable.

#### 2 - Sécurité

Les coachs E-Sportif proposerons des Roadmaps personnalisées, l'application se doit être sécurisée pour éviter les vols et le plagiat.

#### 3 - Évolutivité

Une version mobile de l'application sera développée.
L'intégration d'une dizaine de jeux de combats est prévue courant 2026.

#### 4 - Coûts

L'équipe étant réduite la plateforme ne doit pas coûter cher à développer et maintenir.

### C - Fonctionnalités

- Création/affichage/partage de Roadmaps
- Chats
- Paiement/Abonnements

### D - Compétences techniques

L'équipe est composé d'un développeur, de ce fait il aura la charge de développer l'entièreté du projet (Front-End, Back-End et mobile).

Le développeur connaît les technologies suivantes :

#### 1 - Langage Front-End

- **Javascript** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/JavaScript-logo.png/600px-JavaScript-logo.png" width="30px" alt="Javascript logo" />
- **Typescript** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/1200px-Typescript_logo_2020.svg.png" width="30px" alt="Typescript logo" />
- **CSS** <img src="https://cdn.pixabay.com/photo/2017/08/05/11/16/logo-2582747_1280.png" width="30px" alt="CSS logo" />

#### 2 - Langage Back-End

- **Java** <img src="https://logos-marques.com/wp-content/uploads/2021/03/Java-Logo.png" width="30px" alt="Java logo"/>
- **Go** <img src="https://cdn.worldvectorlogo.com/logos/golang-gopher.svg" width="30px" alt="Golang logo" />
- **NodeJs** <img src="https://static-00.iconduck.com/assets.00/node-js-icon-454x512-nztofx17.png" width="30px" alt="NodeJS logo" />
- **Python** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/701px-Python-logo-notext.svg.png" width="30px" alt="Python logo" />

#### 3 - Framework Front-End

- **ReactJS** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/React-icon.svg/2300px-React-icon.svg.png" width="30px" alt="ReactJS logo" />
- **AngularJS** <img src="https://seeklogo.com/images/A/angular-icon-logo-5FC0C40EAC-seeklogo.com.png" width="30px" alt="AngularJS logo" />

#### 4 - Framework Back-End

- **Spring Boot** <img src="https://img.icons8.com/?size=512&id=90519&format=png" width="30px" alt="Spring Boot logo" />
- **Fiber** <img src="https://repository-images.githubusercontent.com/234231371/00fd8700-5430-11ea-820b-15fd85b2472c" width="30px" alt="Fiber logo" />
- **ExpressJS** <img src="https://upload.wikimedia.org/wikipedia/commons/6/64/Expressjs.png" width="30px" alt="ExpressJS logo" />
- **Flask** <img src="https://cdn.worldvectorlogo.com/logos/flask.svg" width="30px" alt="Flask logo" />

#### 5 - Base de données

- **MongoDB** <img src="https://www.svgrepo.com/show/331488/mongodb.svg" width="30px" alt="MongoDB logo" />
- **PostgreSQL** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Postgresql_elephant.svg/993px-Postgresql_elephant.svg.png" width="30px" alt="PostgreSQL logo" />

Affinité du développeur avec chaque technologie :

| Technologie    | Affinité | Explication                                                                                     |
|----------------|----------------|-------------------------------------------------------------------------------------------------|
| **JavaScript** | 4              | Utilisé quotidiennement, le développeur est familier avec son écosystème.                        |
| **TypeScript** | 3              | Utilisé régulièrement, le développeur est familier avec son écosystème.                          |
| **Java**       | 4              | Langage d’origine, le développeur est familier avec son écosystème.                             |
| **Go**         | 2              | Expérience de quelques side-projects, mais sans grande profondeur dans le langage.              |
| **Python**     | 3              | A travaillé sur quelques projets, une certaine familiarité.                                     |
| **ReactJS**    | 3              | Utilisé quotidiennement, le développeur est familier avec son écosystème.                        |
| **Angular**    | 3              | Quelques side-projects, une certaine familiarité mais pas en profondeur.                        |
| **Spring Boot**| 4              | Langage d’origine, le développeur est familier avec son écosystème.                             |
| **Fiber**      | 2              | Expérience de quelques side-projects, mais pas de grande profondeur.                            |
| **ExpressJS**  | 4              | Utilisé quotidiennement avec JavaScript, le développeur est familier avec son écosystème.       |
| **Flask**      | 2              | A travaillé sur quelques projets mais sans grande profondeur.                                   |
| **MongoDB**    | 4              | Utilisé quotidiennement, le développeur est familier avec son écosystème.                        |
| **PostgreSQL** | 2              | Quelques projets, mais sans grande profondeur.                                                 |

## II - Matrices décisionnelles

<p align="center">
  <a href="https://youtu.be/3FmN46XQius" target="blank"><img src="https://file.forms.app/sitefile/Decision-Matrix-Analysis-1.png" width="800" alt="Matrices de décisions" /></a>

### A - Langages Front-End

Les langages Front-End sélectionnés sont choisi en fonction deplusieurs critères d'évaluation. Les langages choisis sont **JavaScript**, **TypeScript**, et **Dart**.

Le **Dart** est intégrer dans cette liste car il permet un développement Full-Stack (web et mobile).

Les notes vont de 1 à 5, 1 correspondant à "non maîtrisé" et 5 à "pleinement maîtrisé".

Ces informations s’appuient sur des sources diverses telles que <a href="https://survey.stackoverflow.co/2024/" target="_blank">**Stack Overflow Developer Survey**</a>, <a href="https://stateofjs.com/en-US" target="_blank">**State of JS 2022**</a>, <a href="https://mdn.dev/archives/insights/" target="_blank">**MDN Web Docs**</a>.

<u><b>Critères d'évaluations :</b></u>

- **Performance**

Avoir un langage performant permet d'avoir une application plus rapide et de réduire la consommation d'énergie allouée.

- **Facilité d'apprentissage**

Les langages bas niveaux (C, Rust, Scala) ont tendances à  être plus difficiles à maîtriser que les langages haut niveau (Python, Javascript).

- **Coût de développement**

Certains langages ne sont pas open-source, d'autres sont plus long à travailler avec.

- **Durabilité à long terme**

L'évolutivité du langage est importante, un langage non maintenu peut avoir des failles de sécurité, mais aussi une communauté inactive.

- **Temps de développement**

Lié au coût de développement un langage qui prend trop de temps de développement est contraignant pour des raisons économiques et de deadlines.

- **Consommation d'énergie**

Pour des raison environnementales et économiques le langage doit avoir une consommation basse.

- **Popularité du langage**

Avoir une communauté active pour demander de l'aide permet d'avoir un temps de développement réduit.

| Langages     | Performance | Facilité d'apprentissage | Coût de développement | Durabilité à long terme | Temps de développement | Consommation d'énergie | Popularité du langage  | Maîtrise du développeur |
|--------------|-------------|--------------------------|------------------------|-------------------------|------------------------|------------------------|------------------------|--------------------------|
| JavaScript   | 4           | 4                        | 4                      | 5                       | 5                      | 3                      | 5                                             | 4                        |
| TypeScript   | 4           | 3                        | 4                      | 5                       | 4                      | 3                      | 4                                             | 3                        |
| Dart         | 3           | 3                        | 3                      | 4                       | 3                      | 4                      | 3                                             | 0                      |

JavaScript a initialement été conçu comme un langage côté client, il s'est ensuite étendu au développement côté serveur. Cependant, ses limites en matière de programmation orientée objet et son typage dynamique peuvent rendre son adoption complexe pour les projets de grande envergure. Pour combler ces lacunes, TypeScript a été introduit en tant que couche supplémentaire de JavaScript, en y ajoutant notamment le typage statique et d'autres fonctionnalités facilitant la gestion de projets à grande échelle.

TypeScript complète Javascript, c'est un langage orienté objet qui offre des fonctionnalités absentes en JavaScript, comme le typage statique et le support des interfaces. Le typage statique permet de détecter des erreurs dès la compilation, ce qui réduit les erreurs lors des compilation. TypeScript est compatible avec JavaScript et permet d'utiliser les bibliothèques JavaScript existantes tout en intégrant du code TypeScript, donc les 2 langages se complètes.

**Source :**

<a href="https://www.geeksforgeeks.org/difference-between-typescript-and-javascript/" target="_blank">Geeks For Geeks</a>

### B - Langages Back-End

L'avantage du Back-End est qu'il pourra servir pour toutes les solutions Front-End et/ou mobile.
**Rust** est intégré dans cette liste car c'est un langage que le dévelopeur peut potentiellement utiliser pour le projet.
Les critères de notations pour les langages Back-End sont les mêmes que les langages Front-End.

| Langages | Performance | Facilité d'apprentissage | Coût de développement | Durabilité à long terme | Temps de développement | Consommation d'énergie | Popularité du langage | Syntaxe et lisibilité | Maîtrise du développeur |
|----------|-------------|--------------------------|------------------------|-------------------------|------------------------|------------------------|------------------------|------------------------|--------------------------|
| Java     | 5           | 3                        | 4                      | 5                       | 4                      | 4                      | 5                      | 4                      | 4                        |
| Go       | 5           | 3                        | 4                      | 4                       | 3                      | 5                      | 4                      | 4                      | 2                        |
| Python   | 4           | 5                        | 3                      | 5                       | 5                      | 3                      | 5                      | 5                      | 3                        |
| Rust     | 5           | 2                        | 3                      | 5                       | 3                      | 5                      | 3                      | 3                      | 0                      |

**Python**

L'avantage principal de Python est sa syntaxe, elle est claire et lisible. Il dispose de frameworks très populaire et robustes comme Django (orienté MVC) et Flask (micro-framework) qui s’adaptent aux petites applications jusqu'au grandes structures complexes. Le problème de Python c'est sa performance sur des applications multi-thread en raison de son GIL (Global Interpreter Lock). Il a cependant un écosystème très développé et une large communauté.

**Java**

Java est un langage orienté objet robuste, il est apprécié pour sa stabilité et surtout pour sa sécurité. Il est en général privilégié dans les grandes entreprises. Les frameworks comme Spring permettent de construire des applications complexes et évolutives, ce qui fait de Java un choix privilégié pour des projets nécessitant une gestion de transactions lourdes. Cependant, Java peut être verbeux contrairement aux langages et est plus complexe à appréhender, bien qu’il bénéficie d’une communauté massive et de nombreux outils.

**Go**

Go (ou Golang) se distingue par sa simplicité et sa performance, il est parfait pour les systèmes distribués et les microservices. Avec son support natif de la concurrence (goroutines), Go est idéal pour les applications qui nécessitent une grande scalabilité. Il a cependant un écosystème plus jeune contrairement aux autre langages de cette liste, certains outils et frameworks ne sont pas encore aussi matures que ceux des autres langages.

**Rust**

Rust a été créé pour résoudre des problèmes complexes de gestion de mémoire et de performance, il est devenu l’un des langages les plus appréciés dans le monde du développement logiciel, avec un statut "langage le plus aimé" dans le sondage Stack Overflow 2023. Rust propose une syntaxe moderne, une sécurité mémoire stricte, et des capacités avancées de concurrence, offrant ainsi des performances robustes pour le développement de systèmes et le back-end. Son adoption par des entreprises majeures comme Amazon, Discord, et Cloudflare témoigne de sa puissance dans des environnements exigeants. Il se démarque par son modèle de propriété, qui garantit la sécurité de la mémoire sans avoir recours à un ramasse-miettes (garbage collector). Ce modèle, combiné avec un typage statique, permet de détecter les erreurs avant la compilation, minimisant les risques d’erreurs mémoire et améliorant la fiabilité des applications. Il offre des abstractions zéro-coût, optimisant les performances sans sacrifier la lisibilité du code. Ses fonctionnalités modernes lui permettent de réduire le temps d'exécution des applications, ce qui le rend adapté aux projets nécessitant des performances élevées. Il a une communauté active, avec une documentation complète, des forums de soutien.

**Source :**

- <a href="https://roadmap.sh/backend/languages" target="_blank">Roadmap.sh</a>
- <a href="https://strapi.io/blog/rust-vs-other-programming-languages-what-sets-rust-apart" target="_blank">Strapi</a>

### C - Frameworks Front-End

Le développeur est entièrement ouvert concernant le choix du Framework Front-End. Il a cependant quelques réserves sur l'utilisation de Flutter (car il ne maîtrise pas le Dart bien qu'il se rapproche du Javascript).

| Framework | Performance | Écosystème | Développement | Architecture | Déploiement | Sécurité | Coûts | Mobile/Responsive |
|-----------|-------------|------------|---------------|--------------|-------------|----------|-------|--------------------|
| Vue.js    | 4           | 4          | 5             | 4            | 5           | 4        | 5     | 4                  |
| Svelte    | 5           | 3          | 4             | 3            | 4           | 3        | 5     | 4                  |
| Angular   | 4           | 5          | 3             | 5            | 5           | 5        | 4     | 5                  |
| Flutter (Web) | 3       | 3          | 4             | 4            | 4           | 4        | 5     | 5                  |

**Angular**

C'est un framework Front-End complet, il est souvent privilégié pour des applications de grande envergure qui nécessitent un support robuste et une architecture complexe. Développé par Google, Angular utilise TypeScript, comme nous l'avons souligné précédemment ça favorise la détection des erreurs lors du développement. Son architecture est modulaire et permet de gérer des fonctionnalités riches et d'assurer une évolutivité. Il a cependant une courbe d'apprentissage plutôt raide, ce qui peut nécessiter un certain temps d'adaptation.

**Vue**

est un framework progressif, créé par <a href="https://evanyou.me/" target="_blank">Evan You</a>, qui allie les avantages d’Angular et la librairie React. Léger et rapide à télécharger, Vue est facile à prendre en main, ce qui en fait un excellent choix pour les développeurs débutants ou pour des projets nécessitant une application légère et performante. Vue utilise un DOM virtuel et prend en charge la liaison de données bidirectionnelle, ce qui le rend efficace pour gérer des applications de taille moyenne. Cependant, bien que sa communauté soit en pleine croissance, elle reste plus petite que celle d’Angular et de React, ce qui limite les ressources d’apprentissage pour les grands projets.

**Svelte**

Svelte propose une approche radicalement différente des autres frameworks en déplaçant la majorité du travail vers une étape de compilation. Contrairement aux autres frameworks qui utilisent le DOM virtuel, Svelte compile directement en JavaScript pur, ce qui optimise les performances et réduit le poids de l’application. Son code est naturellement réactif sans besoin de syntaxe spéciale, et son apprentissage est facilité par l'utilisation de HTML, CSS, et JavaScript/TypeScript standards. Cependant, Svelte a une communauté plus petite et un écosystème limité, ce qui peut poser des défis pour les projets plus complexes nécessitant des bibliothèques tierces.

**Sources :**

- <a href="https://radixweb.com/blog/angular-vs-react-vs-vue" target="_blank">Radix.com</a>
- <a href="https://kinsta.com/blog/svelte-vs-react/" target="_blank">Kinsta</a>

### D - Frameworks Back-End

| Framework  | Performance | Écosystème | Développement | Architecture | Déploiement | Sécurité | Coûts | Mobile/Responsive |
|------------|-------------|------------|---------------|--------------|-------------|----------|-------|--------------------|
| Django (Python) | 3           | 5          | 4             | 5            | 5           | 5        | 5     | 4                  |
| Express (Node.js) | 4       | 5          | 5             | 4            | 5           | 4        | 5     | 4                  |
| Spring Boot (Java) | 5       | 4          | 3             | 5            | 4           | 5        | 4     | 4                  |
| Gin (Go)         | 5           | 3          | 3             | 4            | 5           | 5        | 4     | 4                  |

**Django**

Django est le framework qui correspond aux applications qui nécessitent une grande sécurité et une scalabilité robuste. Il a une approche "batteries-included", il fournit plusieurs outils pour gérer différents aspects d'une application : l'authentification, la gestion de bases de données et le SEO par exemple. Il est notamment apprécié dans les secteurs qui nécessitent des applications rapides à mettre en œuvre, comme les médias sociaux ou les plateformes de contenu.

**Express.js**

Express est le framework de l'environnement NodeJS (Javascript). C'est un framework minimaliste, il très performant et flexible et souvent choisi pour des applications avec la pile de technologies MEAN (MongoDB, Express.js, AngularJS et Node.js) et MERN (MongoDB, Express, React et Node.js). Express est un framework simple d'utilisation. Sa simplicité et sa compatibilité avec JavaScript côté serveur et client facilitent le développement full-stack. Express est idéal pour les API REST et les applications qui nécessitent du temps réel.

**Spring Boot**

Spring Boot est le framework de l'environnement Java, c'est un framework open-source puissant et généralement pour les applications d'entreprise. Il dispose d'une gestion flexible des dépendances et un support étendu pour les microservices, il est couramment utilisé pour les projets nécessitant une scalabilité horizontale (la scalabilité horizontale signifie qu'une application peut gérer plus de trafic ou de charge en ajoutant davantage de serveurs, plutôt qu'en augmentant la puissance d'un seul serveur) et une forte sécurité.

**Gin**

Go est un langage qui ne nécessite pas de framework, son environnement et ses fonctionnalités lui permettent de réaliser des applications sans passer par un framework. Cependant pour les besoin de notre analyse nous présentons tout de même l'un de ces frameworks les plus connus : Gin.

Gin est un framework minimaliste orienté vers la rapidité et l'efficacité, il parfait pour les microservices et les applications nécessitant un support de traitement rapide. Son architecture est légère et son système de middleware le rendent compétitif pour les API nécessitant des performances optimales.

**Sources :**

- <a href="https://www.geeksforgeeks.org/frameworks-for-backend-development/" target="_blank">GeeksForGeeks</a>
- <a href="https://radixweb.com/blog/best-backend-frameworks" target="_blank">Radixweb.com</a>
- <a href="https://blog.logrocket.com/6-top-go-web-frameworks/" target="_blank">LogRocket.com</a>

### E - Bases de données

Concernant la base de données le critère les critères les plus importants pour le projet sont : **scalabilité**, **sécurité**, **coûts**.

| Base de Données      | Performance | Scalabilité | Fiabilité | Modèle de Données | Sécurité | Coûts | Administration | Intégration | Support et Communauté |
|----------------------|-------------|-------------|-----------|-------------------|----------|-------|----------------|-------------|------------------------|
| **PostgreSQL**       | 5           | 4           | 5         | 4                 | 5        | 4     | 4              | 5           | 5                      |
| **MongoDB**          | 4           | 5           | 4         | 5                 | 4        | 4     | 4              | 5           | 5                      |
| **MySQL**            | 4           | 4           | 5         | 3                 | 5        | 5     | 5              | 4           | 5                      |
| **Firebase Firestore** | 3           | 5           | 4         | 4                 | 5        | 3     | 4              | 5           | 4                      |
| **DynamoDB**         | 4           | 5           | 5         | 4                 | 5        | 3     | 3              | 5           | 4                      |

**Les base de données SQL & NoSQL**

Les bases de données SQL et NoSQL diffèrent principalement dans leur modèle de données, leur flexibilité, et leurs cas d’utilisation privilégiés. Les bases de données SQL, aussi appelées relationnelles, sont structurées en tables avec des lignes et des colonnes, permettant de définir des relations précises entre les données via des clés étrangères et des jointures. Ce modèle favorise une organisation rigide qui garantit l’intégrité et la consistance des données grâce au respect des propriétés ACID (Atomicité, Cohérence, Isolation, Durabilité). SQL est ainsi idéal pour des applications où la précision des transactions est cruciale, comme les systèmes financiers et les e-commerces.

Les bases de données NoSQL, également appelées non relationnelles, adoptent une approche plus flexible en stockant les données sous forme de documents, de paires clé-valeur, de colonnes, ou de graphes. Cette structure est adaptée aux données non structurées ou semi-structurées, ce qui permet d’évoluer et de s’adapter facilement aux modifications de structure. De plus, les bases de données NoSQL sont optimisées pour l’évolutivité horizontale (cf: explications du framework Srping Boot), ce qui signifie qu’elles peuvent gérer des volumes de données massifs en répartissant la charge sur plusieurs serveurs. Ces bases de données sont particulièrement adaptées aux applications nécessitant une haute disponibilité et une flexibilité de stockage, comme les réseaux sociaux, le big data, et les applications IoT.

**MongoDB**

MongoDB est une base de données NoSQL, idéale pour les données non structurées et les applications nécessitant une grande flexibilité et une évolutivité horizontale. Elle stocke les données sous forme de documents JSON, ce qui facilite l’ajout ou la modification de champs. MongoDB est souvent privilégiée pour les applications de gestion de contenu, d'e-commerce ou d'analyses en temps réel. Elle offre une haute disponibilité grâce à la réplication et une mise à l'échelle aisée via le partitionnement, ce qui en fait un bon choix pour les projets à fort volume de données.

**PostgreSQL**

PostgreSQL est une base de données relationnelle robuste, conforme aux normes ACID, qui favorise l'intégrité des données et supporte des requêtes SQL complexes. Conçue pour des données structurées, elle est particulièrement efficace pour les applications transactionnelles et d'e-commerce, grâce à des fonctionnalités avancées de gestion des transactions et d'indexation. PostgreSQL est aussi extensible et supporte JSON, offrant une certaine flexibilité pour des cas d'usage hybrides avec des données semi-structurées.

**MySQL**

MySQL est également une base de données relationnelle, elle est largement utilisée pour sa simplicité et sa fiabilité. Elle convient bien aux applications web de petite à moyenne envergure, comme les systèmes de gestion de contenu ou les applications de type blog. MySQL permet une mise à l'échelle horizontale via le partitionnement et la réplication, mais peut être limitée pour des charges de travail plus complexes nécessitant des jointures et des transactions ACID complexes.

**Firebase**

Firebase est une base de données NoSQL qui se distingue par ses capacités de synchronisation en temps réel et son intégration avec des applications mobiles, notamment via la Google Cloud Platform. Elle est idéale pour les jeux, le chat en direct et les réseaux sociaux, avec des fonctionnalités comme le mode hors ligne et une gestion simplifiée des utilisateurs et des notifications. Cependant, Firebase est fortement liée à l’écosystème Google, ce qui peut poser des défis en matière de migration vers d'autres plateformes.

**DynamoDB**

DynamoDB une autre base de données NoSQL d'Amazon Web Services (AWS), est conçue pour des applications nécessitant une évolutivité et des performances élevées, comme l'IoT ou les analyses de flux de données. Elle supporte un modèle de clé-valeur flexible et propose une scalabilité automatique en fonction de la charge de travail. DynamoDB est adaptée aux charges de travail imprévisibles et s'intègre parfaitement aux autres services AWS, bien qu’elle soit limitée pour les requêtes SQL complexes.

**Sources :**

- <a href="https://aws.amazon.com/fr/compare/the-difference-between-mongodb-and-postgresql/#:~:text=MongoDB%20is%20a%20non%2Drelational,tables%20with%20rows%20and%20columns." target="_blank">AWS</a>
- <a href="https://www.sprinkledata.com/blogs/mysql-vs-dynamodb-a-comprehensive-comparison" target="_blank">Sprinkle Data</a>
- <a href="https://www.ionos.com/digitalguide/server/know-how/mongodb-vs-firebase/" target="_blank">IONOS</a>
- <a href="https://www.ovhcloud.com/fr/learn/sql-vs-nosql/" target="_blank">OVHCloud</a>

## III - Choix final

### A - Langage Front-End

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/1200px-Typescript_logo_2020.svg.png" width="30px" alt="Typescript logo" />

**Typescript**

Pour le langage Front-End nous allons utiliser du Typescript. Comme dit précédemment Typescript est une surcouche à Javascript et Javascript est idéale pour le développement d'application côté client. L'utilisation de Typescript est justifiée pour sa sécurité (notamment grâce au typage) et son éfficacité. Il est utilisable avec tous les frameworks Fron-End, son utilisation permet un large panel de fonctionnalités.

De plus, le développeur a une bonne maîtrise de Javascript, Typescript permet de continuer à exploiter cet écosystème tout en ajoutant des fonctionnalités supplémentaires.

In fine Typescript nous fera bénéficier d'une meilleure gestion du code à long terme, facilitant la maintenance et l'évolution de l'application à mesure qu'elle se développe.

<u>Justifications :</u>

- **Sécurité**
- **Maintenance**
- **Scalabilité**

### B - Framework Front-End

<img src="https://seeklogo.com/images/A/angular-icon-logo-5FC0C40EAC-seeklogo.com.png" width="30px" alt="AngularJS logo" />

**AngularJS**

Nous utiliserons Angular comme framework Front-End.

Le choix d'Angular est justifié par une vision long-termisme, en effet nous souhaitons ne pas avoir à faire de migrations. Pour le développement d'un MVP une autre technologie pourrait être plus adaptée, cependant nous souhaitons dès le début du développement de la plateforme utiliser une  technologie qui va permettre un développement scalable de l'application. Ainsi Angular est le choix par excellence. Angular offre une structure bien définie avec des modules, services et directives, ce qui est crucial pour un projet ayant une vision comme la notre et un besoin d'évolution.

Le framework est conçu pour être extensible, ce qui facilite l'ajout de nouvelles fonctionnalités et l'extension de l'application, répondant ainsi à la nécessité de faire évoluer la plateforme pour intégrer plus de jeux de combat.

De plus, Angular propose des outils de sécurisation (comme la gestion des injections de dépendances).

<u>Justifications :</u>

- **Scalabilité**
- **Sécurité**

### C - Langage Back-End

<img src="https://logos-marques.com/wp-content/uploads/2021/03/Java-Logo.png" width="30px" alt="Java logo"/>

**Java**

Java est le choix idéal pour le développement de notre plateforme côté Back-End.
Le Back-End sera utilisé pour l'ensemble des environnements (web, mobile).

Notre choix s'est porté sur Java car avec son écosystème solide et sa capacité à gérer des applications complexes, Java répond aux besoins d'une plateforme évolutive qui doit traiter de grandes quantités de données à long terme si l'application venait à évoluer dans ce sens.
Il offre une gestion de la mémoire et des performances exceptionnelles, ce qui est important pour une application nécessitant une forte capacité de traitement et une gestion efficace des données.

Aussi il est très utilisé et soutenu par une large communauté, ce qui garantit une vaste documentation, des outils et des bibliothèques pour accélérer le développement.

<u>Justifications :</u>

- **Performance**
- **Écosystème**

### D - Framework Back-End

<img src="https://img.icons8.com/?size=512&id=90519&format=png" width="30px" alt="Spring Boot logo" />

**Spring Boot**

Pour accompagner le développement en Java nous utiliserons le framework Back-End Spring Boot.

Spring Boot permet de construire des applications performantes et scalables, ce qui est essentiel pour une plateforme qui doit évoluer avec l'ajout de nouvelles fonctionnalités et jeux de combat.
Il propose de nombreux mécanismes de sécurité, comme la gestion des sessions, la protection contre les attaques XSS et CSRF, ce qui est crucial pour garantir la sécurité des utilisateurs et des coachs e-sportifs sur la plateforme.
De plus, il facilite le développement rapide grâce à ses fonctionnalités de configuration automatique et sa large adoption dans les entreprises, ce qui permet de maintenir un bon niveau de productivité avec un code simple et robuste.

<u>Justifications :</u>

- **Sécurité**
- **Communauté**
- **Scalabilité**

### E - Base de données

<img src="https://www.svgrepo.com/show/331488/mongodb.svg" width="30px" alt="MongoDB logo" />

**MongoDB**

Le choix de la base de données va se porter sur MongoDB notamment pour des besoins de flexibilité.

L'application étant encore en constructions énorméments de changements auront lieux lors du développement et dans ces conditions forte en variabilité dans la structure des données, MongoDB est une option intéressante, notamment pour des données non structurées ou semi-structurées (par exemple, des profils de joueurs, des roadmaps personnalisées). MongoDB est particulièrement performant pour les applications avec de gros volumes de données et une forte exigence de scalabilité horizontale.

<u>Justifications :</u>

- **Flexibilité**
- **Simplicité**
- **Performance**
