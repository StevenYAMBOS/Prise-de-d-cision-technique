 

<p align="center">

<a href="https://youtu.be/3FmN46XQius" target="blank"><img src="https://ik.imagekit.io/mdzi40eohii/tsc/Full_Stack_Image_daa0e85929_mkCd6n2su.png?tr=w-3840,q-75" width="800" alt="Pile technologique" /></a>

</p>

  

## Sommaire

  

- [I - Smash Here](#i---smash-here)

- [A - Introduction](#a---introduction)

- [B - Vision](#b---vision)

- [Scalabilité](#1---scalabilité)

- [Sécurité](#2---sécurité)

- [Évolutivité](#3---évolutivité)

- [Coûts](#4---coûts)

- [C - Fonctionnalités](#c---fonctionnalités)

- [D - Compétences techniques](#d---compétences-techniques)

- [1 - Langage Front-End](#1---langage-front-end)

- [2 - Langage Back-End](#2---langage-back-end)

- [3 - Framework Front-End](#3---framework-front-end)

- [4 - Framework Back-End](#4---framework-back-end)

- [5 - Base de données](#5---base-de-données)

  

- [II - Matrices décisionnelles](#ii---matrices-décisionnelles)

- [A - Langages Front-End](#a---langages-front-end)

- [B - Langages Back-End](#b---langages-back-end)

- [C - Frameworks Front-End](#c---frameworks-front-end)

- [D - Frameworks Back-End](#d---frameworks-back-end)

- [E - Bases de données](#e---bases-de-données)

  

- [III - Choix final](#iii---choix-final)

- [A - Langage Front-End](#a---langage-front-end-1)

- [B - Framework Front-End](#b---framework-front-end-1)

- [C - Langage Back-End](#c---langage-back-end-1)

- [D - Framework Back-End](#d---framework-back-end-1)

- [E - Base de données](#e---base-de-données-1)

  

  

## I - Smash Here

  

### A - Introduction

  

**Smash Here** est une plateforme e-sport dédiée aux jeux de combat.

  

Elle vise à offrir aux joueurs et coachs des outils d'apprentissage interactifs et personnalisés sous forme de roadmaps adaptées aux différents niveaux de compétence de chacun.

  

### B - Vision

  

  

Smash Here sera dans un premier temps une plateforme Web, puis sur le long terme développée sur mobile (Android et iOS) nativement dans l'idée d'y ajouter des fonctionnalités Natives.

  

Le développement de la plateforme va se concentrer sur les points suivants :

  

#### 1 - Scalabilité

  

Au fur et à mesure des mises à jour la plateforme emmagasinera énormément de données/informations, l elle se doit d'être scalable.

#### 2 - Sécurité

  

Les coachs E-Sportif proposerons des Roadmaps personnalisées, l'application se doit être sécurisée pour éviter les vols et le plagiat.

  

#### 3 - Évolutivité

  

Une version mobile de l'application sera développée.

L'intégration d'une dizaine de jeux de combats est prévue courant 2026.

  

#### 4 - Coûts

  

L'équipe étant réduite la plateforme ne doit pas coûter cher à développer et maintenir.

  

### C - Fonctionnalités

  

- Création/affichage/partage de Roadmaps

- Chats

- Paiement/Abonnements

  

### D - Compétences techniques

  

L'équipe est composé d'un développeur, de ce fait il aura la charge de développer l'entièreté du projet (Front-End, Back-End et mobile).

  

Le développeur connaît les technologies suivantes :

  

#### 1 - Langage Front-End

  

- **Javascript** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/JavaScript-logo.png/600px-JavaScript-logo.png" width="30px" alt="Javascript logo" />

- **Typescript** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/1200px-Typescript_logo_2020.svg.png" width="30px" alt="Typescript logo" />

- **CSS** <img src="https://cdn.pixabay.com/photo/2017/08/05/11/16/logo-2582747_1280.png" width="30px" alt="CSS logo" />

  

#### 2 - Langage Back-End

  

- **Java** <img src="https://logos-marques.com/wp-content/uploads/2021/03/Java-Logo.png" width="30px" alt="Java logo"/>

- **Go** <img src="https://cdn.worldvectorlogo.com/logos/golang-gopher.svg" width="30px" alt="Golang logo" />

- **NodeJs** <img src="https://static-00.iconduck.com/assets.00/node-js-icon-454x512-nztofx17.png" width="30px" alt="NodeJS logo" />

- **Python** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/701px-Python-logo-notext.svg.png" width="30px" alt="Python logo" />

  

#### 3 - Framework Front-End

  

- **ReactJS** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/React-icon.svg/2300px-React-icon.svg.png" width="30px" alt="ReactJS logo" />

- **AngularJS** <img src="https://seeklogo.com/images/A/angular-icon-logo-5FC0C40EAC-seeklogo.com.png" width="30px" alt="AngularJS logo" />

  

#### 4 - Framework Back-End

  

- **Spring Boot** <img src="https://img.icons8.com/?size=512&id=90519&format=png" width="30px" alt="Spring Boot logo" />

- **Fiber** <img src="https://repository-images.githubusercontent.com/234231371/00fd8700-5430-11ea-820b-15fd85b2472c" width="30px" alt="Fiber logo" />

- **ExpressJS** <img src="https://upload.wikimedia.org/wikipedia/commons/6/64/Expressjs.png" width="30px" alt="ExpressJS logo" />

- **Flask** <img src="https://cdn.worldvectorlogo.com/logos/flask.svg" width="30px" alt="Flask logo" />

  

#### 5 - Base de données

  

- **MongoDB** <img src="https://www.svgrepo.com/show/331488/mongodb.svg" width="30px" alt="MongoDB logo" />

- **PostgreSQL** <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Postgresql_elephant.svg/993px-Postgresql_elephant.svg.png" width="30px" alt="PostgreSQL logo" />

  

Affinité du développeur avec chaque technologie :

  

| Technologie | Affinité | Explication |

|----------------|----------------|-------------------------------------------------------------------------------------------------|

| **JavaScript** | 4 | Utilisé quotidiennement, le développeur est familier avec son écosystème. |

| **TypeScript** | 3 | Utilisé régulièrement, le développeur est familier avec son écosystème. |

| **Java** | 4 | Langage d’origine, le développeur est familier avec son écosystème. |

| **Go** | 2 | Expérience de quelques side-projects, mais sans grande profondeur dans le langage. |

| **Python** | 3 | A travaillé sur quelques projets, une certaine familiarité. |

| **ReactJS** | 3 | Utilisé quotidiennement, le développeur est familier avec son écosystème. |

| **Angular** | 3 | Quelques side-projects, une certaine familiarité mais pas en profondeur. |

| **Spring Boot**| 4 | Langage d’origine, le développeur est familier avec son écosystème. |

| **Fiber** | 2 | Expérience de quelques side-projects, mais pas de grande profondeur. |

| **ExpressJS** | 4 | Utilisé quotidiennement avec JavaScript, le développeur est familier avec son écosystème. |

| **Flask** | 2 | A travaillé sur quelques projets mais sans grande profondeur. |

| **MongoDB** | 4 | Utilisé quotidiennement, le développeur est familier avec son écosystème. |

| **PostgreSQL** | 2 | Quelques projets, mais sans grande profondeur. |

  

## II - Matrices décisionnelles

  

<p align="center">

<a href="https://youtu.be/3FmN46XQius" target="blank"><img src="https://file.forms.app/sitefile/Decision-Matrix-Analysis-1.png" width="800" alt="Matrices de décisions" /></a>

  

### A - Langages Front-End

  

Les langages Front-End sélectionnés sont choisi en fonction deplusieurs critères d'évaluation. Les langages choisis sont **JavaScript**, **TypeScript**, et **Dart**.

  

Le **Dart** est intégrer dans cette liste car il permet un développement Full-Stack (web et mobile).

  

Les notes vont de 1 à 5, 1 correspondant à "non maîtrisé" et 5 à "pleinement maîtrisé".

  

Ces informations s’appuient sur des sources diverses telles que <a href="https://survey.stackoverflow.co/2024/" target="_blank">**Stack Overflow Developer Survey**</a>, <a href="https://stateofjs.com/en-US" target="_blank">**State of JS 2022**</a>, <a href="https://mdn.dev/archives/insights/" target="_blank">**MDN Web Docs**</a>.

  

<u><b>Critères d'évaluations :</b></u>

  

- **Performance**

  

Avoir un langage performant permet d'avoir une application plus rapide et de réduire la consommation d'énergie allouée.

  

- **Facilité d'apprentissage**

  

Les langages bas niveaux (C, Rust, Scala) ont tendances à être plus difficiles à maîtriser que les langages haut niveau (Python, Javascript).

  

- **Coût de développement**

  

Certains langages ne sont pas open-source, d'autres sont plus long à travailler avec.

  

- **Durabilité à long terme**

  

L'évolutivité du langage est importante, un langage non maintenu peut avoir des failles de sécurité, mais aussi une communauté inactive.

  

- **Temps de développement**

  

Lié au coût de développement un langage qui prend trop de temps de développement est contraignant pour des raisons économiques et de deadlines.

  

- **Consommation d'énergie**

  

Pour des raison environnementales et économiques le langage doit avoir une consommation basse.

  

- **Popularité du langage**

  

Avoir une communauté active pour demander de l'aide permet d'avoir un temps de développement réduit.

  

| Langages | Performance | Facilité d'apprentissage | Coût de développement | Durabilité à long terme | Temps de développement | Consommation d'énergie | Popularité du langage | Maîtrise du développeur |

|--------------|-------------|--------------------------|------------------------|-------------------------|------------------------|------------------------|------------------------|--------------------------|

| JavaScript | 4 | 4 | 4 | 5 | 5 | 3 | 5 | 4 |

| TypeScript | 4 | 3 | 4 | 5 | 4 | 3 | 4 | 3 |

| Dart | 3 | 3 | 3 | 4 | 3 | 4 | 3 | 0 |

  

JavaScript a initialement été conçu comme un langage côté client, il s'est ensuite étendu au développement côté serveur. Cependant, ses limites en matière de programmation orientée objet et son typage dynamique peuvent rendre son adoption complexe pour les projets de grande envergure. Pour combler ces lacunes, TypeScript a été introduit en tant que couche supplémentaire de JavaScript, en y ajoutant notamment le typage statique et d'autres fonctionnalités facilitant la gestion de projets à grande échelle.

  

TypeScript complète Javascript, c'est un langage orienté objet qui offre des fonctionnalités absentes en JavaScript, comme le typage statique et le support des interfaces. Le typage statique permet de détecter des erreurs dès la compilation, ce qui réduit les erreurs lors des compilation. TypeScript est compatible avec JavaScript et permet d'utiliser les bibliothèques JavaScript existantes tout en intégrant du code TypeScript, donc les 2 langages se complètes.

  

**Source :**

  

<a href="https://www.geeksforgeeks.org/difference-between-typescript-and-javascript/" target="_blank">Geeks For Geeks</a>

  

### B - Langages Back-End

  

L'avantage du Back-End est qu'il pourra servir pour toutes les solutions Front-End et/ou mobile.

**Rust** est intégré dans cette liste car c'est un langage que le dévelopeur peut potentiellement utiliser pour le projet.

Les critères de notations pour les langages Back-End sont les mêmes que les langages Front-End.

  

| Langages | Performance | Facilité d'apprentissage | Coût de développement | Durabilité à long terme | Temps de développement | Consommation d'énergie | Popularité du langage | Syntaxe et lisibilité | Maîtrise du développeur |

|----------|-------------|--------------------------|------------------------|-------------------------|------------------------|------------------------|------------------------|------------------------|--------------------------|

| Java | 5 | 3 | 4 | 5 | 4 | 4 | 5 | 4 | 4 |

| Go | 5 | 3 | 4 | 4 | 3 | 5 | 4 | 4 | 2 |

| Python | 4 | 5 | 3 | 5 | 5 | 3 | 5 | 5 | 3 |

| Rust | 5 | 2 | 3 | 5 | 3 | 5 | 3 | 3 | 0 |

  

**Python**

  

L'avantage principal de Python est sa syntaxe, elle est claire et lisible. Il dispose de frameworks très populaire et robustes comme Django (orienté MVC) et Flask (micro-framework) qui s’adaptent aux petites applications jusqu'au grandes structures complexes. Le problème de Python c'est sa performance sur des applications multi-thread en raison de son GIL (Global Interpreter Lock). Il a cependant un écosystème très développé et une large communauté.

  

**Java**

  

Java est un langage orienté objet robuste, il est apprécié pour sa stabilité et surtout pour sa sécurité. Il est en général privilégié dans les grandes entreprises. Les frameworks comme Spring permettent de construire des applications complexes et évolutives, ce qui fait de Java un choix privilégié pour des projets nécessitant une gestion de transactions lourdes. Cependant, Java peut être verbeux contrairement aux langages et est plus complexe à appréhender, bien qu’il bénéficie d’une communauté massive et de nombreux outils.

  

**Go**

  

Go (ou Golang) se distingue par sa simplicité et sa performance, il est parfait pour les systèmes distribués et les microservices. Avec son support natif de la concurrence (goroutines), Go est idéal pour les applications qui nécessitent une grande scalabilité. Il a cependant un écosystème plus jeune contrairement aux autre langages de cette liste, certains outils et frameworks ne sont pas encore aussi matures que ceux des autres langages.

  

**Rust**

  

Rust a été créé pour résoudre des problèmes complexes de gestion de mémoire et de performance, il est devenu l’un des langages les plus appréciés dans le monde du développement logiciel, avec un statut "langage le plus aimé" dans le sondage Stack Overflow 2023. Rust propose une syntaxe moderne, une sécurité mémoire stricte, et des capacités avancées de concurrence, offrant ainsi des performances robustes pour le développement de systèmes et le back-end. Son adoption par des entreprises majeures comme Amazon, Discord, et Cloudflare témoigne de sa puissance dans des environnements exigeants. Il se démarque par son modèle de propriété, qui garantit la sécurité de la mémoire sans avoir recours à un ramasse-miettes (garbage collector). Ce modèle, combiné avec un typage statique, permet de détecter les erreurs avant la compilation, minimisant les risques d’erreurs mémoire et améliorant la fiabilité des applications. Il offre des abstractions zéro-coût, optimisant les performances sans sacrifier la lisibilité du code. Ses fonctionnalités modernes lui permettent de réduire le temps d'exécution des applications, ce qui le rend adapté aux projets nécessitant des performances élevées. Il a une communauté active, avec une documentation complète, des forums de soutien.

  

**Source :**

  

- <a href="https://roadmap.sh/backend/languages" target="_blank">Roadmap.sh</a>

- <a href="https://strapi.io/blog/rust-vs-other-programming-languages-what-sets-rust-apart" target="_blank">Strapi</a>

  

### C - Frameworks Front-End

  

Le développeur est entièrement ouvert concernant le choix du Framework Front-End. Il a cependant quelques réserves sur l'utilisation de Flutter (car il ne maîtrise pas le Dart bien qu'il se rapproche du Javascript).

  

| Framework | Performance | Écosystème | Développement | Architecture | Déploiement | Sécurité | Coûts | Mobile/Responsive |

|-----------|-------------|------------|---------------|--------------|-------------|----------|-------|--------------------|

| Vue.js | 4 | 4 | 5 | 4 | 5 | 4 | 5 | 4 |

| Svelte | 5 | 3 | 4 | 3 | 4 | 3 | 5 | 4 |

| Angular | 4 | 5 | 3 | 5 | 5 | 5 | 4 | 5 |

| Flutter (Web) | 3 | 3 | 4 | 4 | 4 | 4 | 5 | 5 |

  

**Angular**

  

C'est un framework Front-End complet, il est souvent privilégié pour des applications de grande envergure qui nécessitent un support robuste et une architecture complexe. Développé par Google, Angular utilise TypeScript, comme nous l'avons souligné précédemment ça favorise la détection des erreurs lors du développement. Son architecture est modulaire et permet de gérer des fonctionnalités riches et d'assurer une évolutivité. Il a cependant une courbe d'apprentissage plutôt raide, ce qui peut nécessiter un certain temps d'adaptation.

  

**Vue**

  

est un framework progressif, créé par <a href="https://evanyou.me/" target="_blank">Evan You</a>, qui allie les avantages d’Angular et la librairie React. Léger et rapide à télécharger, Vue est facile à prendre en main, ce qui en fait un excellent choix pour les développeurs débutants ou pour des projets nécessitant une application légère et performante. Vue utilise un DOM virtuel et prend en charge la liaison de données bidirectionnelle, ce qui le rend efficace pour gérer des applications de taille moyenne. Cependant, bien que sa communauté soit en pleine croissance, elle reste plus petite que celle d’Angular et de React, ce qui limite les ressources d’apprentissage pour les grands projets.

  

**Svelte**

  

Svelte propose une approche radicalement différente des autres frameworks en déplaçant la majorité du travail vers une étape de compilation. Contrairement aux autres frameworks qui utilisent le DOM virtuel, Svelte compile directement en JavaScript pur, ce qui optimise les performances et réduit le poids de l’application. Son code est naturellement réactif sans besoin de syntaxe spéciale, et son apprentissage est facilité par l'utilisation de HTML, CSS, et JavaScript/TypeScript standards. Cependant, Svelte a une communauté plus petite et un écosystème limité, ce qui peut poser des défis pour les projets plus complexes nécessitant des bibliothèques tierces.

  

**Sources :**

  

- <a href="https://radixweb.com/blog/angular-vs-react-vs-vue" target="_blank">Radix.com</a>

- <a href="https://kinsta.com/blog/svelte-vs-react/" target="_blank">Kinsta</a>

  

### D - Frameworks Back-End

  

| Framework | Performance | Écosystème | Développement | Architecture | Déploiement | Sécurité | Coûts | Mobile/Responsive |

|------------|-------------|------------|---------------|--------------|-------------|----------|-------|--------------------|

| Django (Python) | 3 | 5 | 4 | 5 | 5 | 5 | 5 | 4 |

| Express (Node.js) | 4 | 5 | 5 | 4 | 5 | 4 | 5 | 4 |

| Spring Boot (Java) | 5 | 4 | 3 | 5 | 4 | 5 | 4 | 4 |

| Gin (Go) | 5 | 3 | 3 | 4 | 5 | 5 | 4 | 4 |

  

**Django**

  

Django est le framework qui correspond aux applications qui nécessitent une grande sécurité et une scalabilité robuste. Il a une approche "batteries-included", il fournit plusieurs outils pour gérer différents aspects d'une application : l'authentification, la gestion de bases de données et le SEO par exemple. Il est notamment apprécié dans les secteurs qui nécessitent des applications rapides à mettre en œuvre, comme les médias sociaux ou les plateformes de contenu.

  

**Express.js**

  

Express est le framework de l'environnement NodeJS (Javascript). C'est un framework minimaliste, il très performant et flexible et souvent choisi pour des applications avec la pile de technologies MEAN (MongoDB, Express.js, AngularJS et Node.js) et MERN (MongoDB, Express, React et Node.js). Express est un framework simple d'utilisation. Sa simplicité et sa compatibilité avec JavaScript côté serveur et client facilitent le développement full-stack. Express est idéal pour les API REST et les applications qui nécessitent du temps réel.

  

**Spring Boot**

  

Spring Boot est le framework de l'environnement Java, c'est un framework open-source puissant et généralement pour les applications d'entreprise. Il dispose d'une gestion flexible des dépendances et un support étendu pour les microservices, il est couramment utilisé pour les projets nécessitant une scalabilité horizontale (la scalabilité horizontale signifie qu'une application peut gérer plus de trafic ou de charge en ajoutant davantage de serveurs, plutôt qu'en augmentant la puissance d'un seul serveur) et une forte sécurité.

  

**Gin**

  

Go est un langage qui ne nécessite pas de framework, son environnement et ses fonctionnalités lui permettent de réaliser des applications sans passer par un framework. Cependant pour les besoin de notre analyse nous présentons tout de même l'un de ces frameworks les plus connus : Gin.

  

Gin est un framework minimaliste orienté vers la rapidité et l'efficacité, il parfait pour les microservices et les applications nécessitant un support de traitement rapide. Son architecture est légère et son système de middleware le rendent compétitif pour les API nécessitant des performances optimales.

  

**Sources :**

  

- <a href="https://www.geeksforgeeks.org/frameworks-for-backend-development/" target="_blank">GeeksForGeeks</a>

- <a href="https://radixweb.com/blog/best-backend-frameworks" target="_blank">Radixweb.com</a>

- <a href="https://blog.logrocket.com/6-top-go-web-frameworks/" target="_blank">LogRocket.com</a>

  

### E - Bases de données

  

Concernant la base de données le critère les critères les plus importants pour le projet sont : **scalabilité**, **sécurité**, **coûts**.

  

| Base de Données | Performance | Scalabilité | Fiabilité | Modèle de Données | Sécurité | Coûts | Administration | Intégration | Support et Communauté |

|----------------------|-------------|-------------|-----------|-------------------|----------|-------|----------------|-------------|------------------------|

| **PostgreSQL** | 5 | 4 | 5 | 4 | 5 | 4 | 4 | 5 | 5 |

| **MongoDB** | 4 | 5 | 4 | 5 | 4 | 4 | 4 | 5 | 5 |

| **MySQL** | 4 | 4 | 5 | 3 | 5 | 5 | 5 | 4 | 5 |

| **Firebase Firestore** | 3 | 5 | 4 | 4 | 5 | 3 | 4 | 5 | 4 |

| **DynamoDB** | 4 | 5 | 5 | 4 | 5 | 3 | 3 | 5 | 4 |

  

**Les base de données SQL & NoSQL**

  

Les bases de données SQL et NoSQL diffèrent principalement dans leur modèle de données, leur flexibilité, et leurs cas d’utilisation privilégiés. Les bases de données SQL, aussi appelées relationnelles, sont structurées en tables avec des lignes et des colonnes, permettant de définir des relations précises entre les données via des clés étrangères et des jointures. Ce modèle favorise une organisation rigide qui garantit l’intégrité et la consistance des données grâce au respect des propriétés ACID (Atomicité, Cohérence, Isolation, Durabilité). SQL est ainsi idéal pour des applications où la précision des transactions est cruciale, comme les systèmes financiers et les e-commerces.

  

Les bases de données NoSQL, également appelées non relationnelles, adoptent une approche plus flexible en stockant les données sous forme de documents, de paires clé-valeur, de colonnes, ou de graphes. Cette structure est adaptée aux données non structurées ou semi-structurées, ce qui permet d’évoluer et de s’adapter facilement aux modifications de structure. De plus, les bases de données NoSQL sont optimisées pour l’évolutivité horizontale (cf: explications du framework Srping Boot), ce qui signifie qu’elles peuvent gérer des volumes de données massifs en répartissant la charge sur plusieurs serveurs. Ces bases de données sont particulièrement adaptées aux applications nécessitant une haute disponibilité et une flexibilité de stockage, comme les réseaux sociaux, le big data, et les applications IoT.

  

**MongoDB**

  

MongoDB est une base de données NoSQL, idéale pour les données non structurées et les applications nécessitant une grande flexibilité et une évolutivité horizontale. Elle stocke les données sous forme de documents JSON, ce qui facilite l’ajout ou la modification de champs. MongoDB est souvent privilégiée pour les applications de gestion de contenu, d'e-commerce ou d'analyses en temps réel. Elle offre une haute disponibilité grâce à la réplication et une mise à l'échelle aisée via le partitionnement, ce qui en fait un bon choix pour les projets à fort volume de données.

  

**PostgreSQL**

  

PostgreSQL est une base de données relationnelle robuste, conforme aux normes ACID, qui favorise l'intégrité des données et supporte des requêtes SQL complexes. Conçue pour des données structurées, elle est particulièrement efficace pour les applications transactionnelles et d'e-commerce, grâce à des fonctionnalités avancées de gestion des transactions et d'indexation. PostgreSQL est aussi extensible et supporte JSON, offrant une certaine flexibilité pour des cas d'usage hybrides avec des données semi-structurées.

  

**MySQL**

  

MySQL est également une base de données relationnelle, elle est largement utilisée pour sa simplicité et sa fiabilité. Elle convient bien aux applications web de petite à moyenne envergure, comme les systèmes de gestion de contenu ou les applications de type blog. MySQL permet une mise à l'échelle horizontale via le partitionnement et la réplication, mais peut être limitée pour des charges de travail plus complexes nécessitant des jointures et des transactions ACID complexes.

  

**Firebase**

  

Firebase est une base de données NoSQL qui se distingue par ses capacités de synchronisation en temps réel et son intégration avec des applications mobiles, notamment via la Google Cloud Platform. Elle est idéale pour les jeux, le chat en direct et les réseaux sociaux, avec des fonctionnalités comme le mode hors ligne et une gestion simplifiée des utilisateurs et des notifications. Cependant, Firebase est fortement liée à l’écosystème Google, ce qui peut poser des défis en matière de migration vers d'autres plateformes.

  

**DynamoDB**

  

DynamoDB une autre base de données NoSQL d'Amazon Web Services (AWS), est conçue pour des applications nécessitant une évolutivité et des performances élevées, comme l'IoT ou les analyses de flux de données. Elle supporte un modèle de clé-valeur flexible et propose une scalabilité automatique en fonction de la charge de travail. DynamoDB est adaptée aux charges de travail imprévisibles et s'intègre parfaitement aux autres services AWS, bien qu’elle soit limitée pour les requêtes SQL complexes.

  

**Sources :**

  

- <a href="https://aws.amazon.com/fr/compare/the-difference-between-mongodb-and-postgresql/#:~:text=MongoDB%20is%20a%20non%2Drelational,tables%20with%20rows%20and%20columns." target="_blank">AWS</a>

- <a href="https://www.sprinkledata.com/blogs/mysql-vs-dynamodb-a-comprehensive-comparison" target="_blank">Sprinkle Data</a>

- <a href="https://www.ionos.com/digitalguide/server/know-how/mongodb-vs-firebase/" target="_blank">IONOS</a>

- <a href="https://www.ovhcloud.com/fr/learn/sql-vs-nosql/" target="_blank">OVHCloud</a>

### F - Hébergements Web

Concernant l'hébergement web nous favorisons un hébergeur Français. Il sera plus simple de respecter le RGPD (Règlement Général de Protection des Données). 
Les options d’hébergement web suivantes ont été sélectionnées : **AWS**, **OVH**, **Netlify**, **Vercel**, et **O2Switch**.

---

#### **Critères d'évaluation :**

1. **Performance générale**  
    Capacité à offrir des temps de chargement rapides et une fiabilité élevée.
    
2. **Disponibilité (Uptime)**  
    Garantie de disponibilité du service pour minimiser les interruptions.
    
3. **Flexibilité des configurations**  
    Possibilité d'adapter les ressources ou d'utiliser des configurations spécifiques (serveurs dédiés, mutualisés, etc.).
    
4. **Support technique**  
    Qualité et disponibilité du support en cas de problème technique.
    
5. **Simplicité de déploiement**  
    Facilité d'installation et de gestion, surtout pour des développeurs individuels ou des petites équipes.
    
6. **Conformité et localisation**  
    Respect des normes légales (par exemple, RGPD mentionné plus tôt) et localisation des serveurs.
    
7. **Coût global**  
    Évaluation des coûts en phase MVP et production.
    

---

|Hébergement|**Performance**|**Disponibilité (Uptime)**|**Flexibilité des configurations**|**Support technique**|**Simplicité de déploiement**|**Conformité et localisation**|**Coût global**|**Score total**|
|---|---|---|---|---|---|---|---|---|
|**AWS**|5|5|5|4|4|4|3|**30**|
|**OVH**|4|4|4|5|4|5|5|**31**|
|**Netlify**|4|4|3|4|5|4|5|**29**|
|**Vercel**|4|4|3|4|5|4|4|**28**|
|**O2Switch**|4|4|4|5|4|5|5|**31**|
|**VPS (Général)**|5|4|5|4|3|4|4|**29**|

---

Voici une version révisée avec des paragraphes globaux pour chaque hébergeur, dans le style demandé :

---

**AWS**  
Amazon Web Services est la plateforme de Cloud Computing d'Amazon, offrant des services d'hébergement web ainsi qu'une vaste gamme de fonctionnalités supplémentaires telles que les instances EC2, le stockage S3 et les bases de données RDS. Avec des performances et une disponibilité parmi les meilleures du marché grâce à son infrastructure globale, AWS est souvent considéré comme la référence en matière de cloud. Il permet une personnalisation avancée et une flexibilité exceptionnelle, répondant aux besoins de projets complexes et évolutifs. Cependant, cette flexibilité et ces performances ont un coût élevé, ce qui en fait une solution moins accessible pour les petites équipes ou les MVPs. AWS est idéal pour des projets ambitieux nécessitant une scalabilité importante et des fonctionnalités techniques avancées.

---

**OVH**  
OVH est un hébergeur basé en France, réputé pour son excellent rapport qualité-prix et ses offres adaptées aux petites et moyennes entreprises. Ses serveurs localisés en Europe assurent une conformité au RGPD, ce qui en fait un choix privilégié pour les projets nécessitant une forte protection des données. OVH propose des configurations flexibles, allant des solutions mutualisées aux serveurs dédiés, et un support technique reconnu pour sa réactivité. Bien qu'il soit légèrement en retrait sur les intégrations natives et les outils automatisés comparé à des solutions modernes comme AWS, OVH reste une option économique et fiable pour des projets européens avec des besoins modérés.

---

**Netlify**  
Netlify est une plateforme d’hébergement spécialement conçue pour les sites JAMstack et les applications front-end modernes. Idéale pour les MVPs, elle offre des déploiements rapides, une intégration fluide avec Git et des fonctionnalités telles que le CI/CD intégré et les fonctions serverless. Bien que ses performances soient optimales pour des sites statiques ou hybrides, Netlify montre ses limites pour les projets nécessitant des backends complexes ou une personnalisation poussée des configurations. Avec une interface intuitive et une mise en œuvre simplifiée, Netlify est un excellent choix pour les développeurs front-end souhaitant un hébergement rapide et efficace.

---

**Vercel**  
Vercel se positionne comme une solution premium pour les frameworks front-end, notamment Next.js, dont elle est l’un des principaux soutiens. Elle se distingue par sa simplicité de déploiement, sa rapidité et ses performances front-end optimisées, avec une approche orientée vers l’expérience utilisateur. Tout comme Netlify, elle est particulièrement adaptée aux projets front-end modernes et aux sites JAMstack. Cependant, elle offre moins de flexibilité pour les besoins backend complexes ou les projets nécessitant une gestion avancée des données. Vercel est idéale pour des applications web front-end nécessitant un rendu rapide et un déploiement optimisé.

---

**O2Switch**  
O2Switch est un hébergeur français qui se démarque par son offre unique « tout illimité » à un prix compétitif. Avec des serveurs basés en France et une conformité au RGPD, il offre une solution fiable et économique, particulièrement adaptée aux projets locaux ou européens. L’interface simple et le support client réactif font d’O2Switch une solution accessible, même pour les développeurs débutants. Bien que ses capacités de scalabilité soient limitées par rapport à des plateformes cloud comme AWS, O2Switch reste un excellent choix pour des projets à budget serré ou nécessitant une gestion simplifiée des ressources.

---

Un **VPS (Virtual Private Server)** est une solution d’hébergement offrant un environnement dédié virtuel sur un serveur physique partagé. Contrairement aux hébergements mutualisés, un VPS garantit des ressources spécifiques (CPU, RAM, espace disque), ce qui améliore considérablement les performances et la stabilité, notamment pour des applications nécessitant des configurations personnalisées ou un trafic modéré à élevé. Les VPS sont très flexibles : ils permettent d'installer un système d'exploitation et des logiciels spécifiques, ce qui les rend idéaux pour des projets nécessitant un contrôle total de l'environnement. Cependant, cette flexibilité s'accompagne d'une complexité accrue, car la gestion (configuration, mise à jour, sécurité) repose souvent sur l'utilisateur. Bien que plus coûteux que l’hébergement mutualisé, un VPS reste une alternative économique aux serveurs dédiés, offrant un bon compromis pour des projets en croissance nécessitant une performance fiable, sans atteindre le coût et la complexité d'une infrastructure cloud complète.

**Sources :**

- [Quel est le meilleur hébergeur web en 2025 ? Le comparatif des meilleures offres.](https://tool-advisor.fr/blog/hebergeur-web/)
- [Les 10 meilleurs hébergeurs web français](https://www.codeur.com/blog/hebergeur-web-francais/)
- [VPS vs. Cloud : quelle est la meilleure solution d’hébergement ?](https://www.ionos.fr/digitalguide/serveur/know-how/vps-vs-cloud/)

Le choix de l’hébergement web est une étape essentielle pour garantir le succès de la plateforme. Chaque option présente des avantages et des compromis qui peuvent influencer la scalabilité, la sécurité, et les coûts du projet, en fonction des besoins spécifiques à chaque phase de développement.

Dans la prochaine section, nous résumerons ces comparaisons pour établir des choix clairs et justifiés, alignés avec les objectifs à court et long terme du projet. Ce processus permettra de définir l’infrastructure technologique la plus adaptée à la vision et aux contraintes de _Smash Here_.

## III - Choix final

### A - Langage Front-End

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/1200px-Typescript_logo_2020.svg.png" width="30px" alt="Typescript logo" />

  

**Typescript**

  

Pour le langage Front-End nous allons utiliser du Typescript. Comme dit précédemment Typescript est une surcouche à Javascript et Javascript est idéale pour le développement d'application côté client. L'utilisation de Typescript est justifiée pour sa sécurité (notamment grâce au typage) et son éfficacité. Il est utilisable avec tous les frameworks Fron-End, son utilisation permet un large panel de fonctionnalités.

  

De plus, le développeur a une bonne maîtrise de Javascript, Typescript permet de continuer à exploiter cet écosystème tout en ajoutant des fonctionnalités supplémentaires.

  

In fine Typescript nous fera bénéficier d'une meilleure gestion du code à long terme, facilitant la maintenance et l'évolution de l'application à mesure qu'elle se développe.

  

<u>Justifications :</u>

  

- **Sécurité**

- **Maintenance**

- **Scalabilité**

  

### B - Framework Front-End

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Svelte_Logo.svg/1200px-Svelte_Logo.svg.png" width="30px" alt="SvelteJS logo" />

**SvelteJS**

Nous utiliserons **SvelteJS** comme framework Front-End. Le choix de SvelteJS est justifié par plusieurs aspects clés pour le développement d'un MVP. Tout d'abord, il permet un développement rapide grâce à sa simplicité et sa structure intuitive, ce qui est crucial dans les phases initiales d’un projet. Svelte est également rapide à prendre en main, ce qui réduit le temps nécessaire pour obtenir un produit fonctionnel. Sur le long terme, nous envisagerons possiblement le développement d'une application mobile. En outre, Svelte permet de développer des Progressive Web Apps (PWA), un atout stratégique pour offrir une expérience mobile de qualité sans avoir besoin de développer une application native.

<u>Justifications :</u>

- **Développement rapide pour un MVP**
- **Rapide à prendre en main**
- **PWA possible**

### C - Langage Back-End

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg" width="30px" alt="Python logo" />

**Python**

Pour le Back-End, nous avons choisi **Python**. Ce langage est reconnu pour sa rapidité de développement, ce qui est essentiel pour construire un MVP rapidement tout en conservant un code clair et maintenable. Python bénéficie d'une grande communauté active, ce qui garantit une documentation abondante et des bibliothèques disponibles pour couvrir une large gamme de besoins. Enfin, son vaste écosystème permet de facilement intégrer des outils pour des fonctionnalités avancées, telles que l'analyse de données ou l'intelligence artificielle, si nécessaire dans l'avenir.

<u>Justifications :</u>

- **Rapidité de développement**
- **Grande communauté**
- **Vaste écosystème**

### D - Framework Back-End

<img src="https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png" width="30px" alt="FastAPI logo" />

**FastAPI** Le framework Back-End choisi est **FastAPI**. Il est performant, moderne, et parfaitement adapté à un projet nécessitant une API REST rapide et fiable. FastAPI utilise des fonctionnalités modernes de Python telles que les annotations de type, ce qui améliore la productivité des développeurs tout en garantissant un code robuste. De plus, FastAPI est conçu pour être scalable, ce qui signifie que l'architecture pourra évoluer facilement au fur et à mesure que la plateforme s’enrichira en fonctionnalités et en utilisateurs. 

<u>Justifications :</u>

- **Performant**
- **Adapté au projet**
- **Scalable**
  

### E - Base de données

  

<img src="https://www.svgrepo.com/show/331488/mongodb.svg" width="30px" alt="MongoDB logo" />

  

**MongoDB**

  

Le choix de la base de données va se porter sur MongoDB notamment pour des besoins de flexibilité.

  

L'application étant encore en constructions énorméments de changements auront lieux lors du développement et dans ces conditions forte en variabilité dans la structure des données, MongoDB est une option intéressante, notamment pour des données non structurées ou semi-structurées (par exemple, des profils de joueurs, des roadmaps personnalisées). MongoDB est particulièrement performant pour les applications avec de gros volumes de données et une forte exigence de scalabilité horizontale.

  

<u>Justifications :</u>

  

- **Flexibilité**

- **Simplicité**

- **Performance**
